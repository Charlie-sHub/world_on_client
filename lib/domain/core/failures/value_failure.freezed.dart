// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'value_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ValueFailureTearOff {
  const _$ValueFailureTearOff();

  NullInput<T> nullInput<T>() {
    return NullInput<T>();
  }

  InvalidDate<T> invalidDate<T>({required DateTime failedValue}) {
    return InvalidDate<T>(
      failedValue: failedValue,
    );
  }

  InvalidEmail<T> invalidEmail<T>({required String failedValue}) {
    return InvalidEmail<T>(
      failedValue: failedValue,
    );
  }

  InvalidPassword<T> invalidPassword<T>({required String failedValue}) {
    return InvalidPassword<T>(
      failedValue: failedValue,
    );
  }

  StringMismatch<T> stringMismatch<T>({required String failedValue}) {
    return StringMismatch<T>(
      failedValue: failedValue,
    );
  }

  InvalidName<T> invalidName<T>({required String failedValue}) {
    return InvalidName<T>(
      failedValue: failedValue,
    );
  }

  EmptyString<T> emptyString<T>({required String failedValue}) {
    return EmptyString<T>(
      failedValue: failedValue,
    );
  }

  MultiLineString<T> multiLineString<T>({required String failedValue}) {
    return MultiLineString<T>(
      failedValue: failedValue,
    );
  }

  StringExceedsLength<T> stringExceedsLength<T>({required String failedValue, required int maxLength}) {
    return StringExceedsLength<T>(
      failedValue: failedValue,
      maxLength: maxLength,
    );
  }

  IntegerOutOfBounds<T> integerOutOfBounds<T>({required int failedValue}) {
    return IntegerOutOfBounds<T>(
      failedValue: failedValue,
    );
  }

  StringWithInvalidCharacters<T> stringWithInvalidCharacters<T>({required String failedValue}) {
    return StringWithInvalidCharacters<T>(
      failedValue: failedValue,
    );
  }

  InvalidCoordinates<T> invalidCoordinate<T>({required double failedValue}) {
    return InvalidCoordinates<T>(
      failedValue: failedValue,
    );
  }

  EmptySet<T> emptySet<T>({required T failedValue}) {
    return EmptySet<T>(
      failedValue: failedValue,
    );
  }

  EmptyList<T> emptyList<T>({required T failedValue}) {
    return EmptyList<T>(
      failedValue: failedValue,
    );
  }

  CollectionExceedsLength<T> collectionExceedsLength<T>({required T failedValue, required int maxLength}) {
    return CollectionExceedsLength<T>(
      failedValue: failedValue,
      maxLength: maxLength,
    );
  }
}

/// @nodoc
const $ValueFailure = _$ValueFailureTearOff();

/// @nodoc
mixin _$ValueFailure<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) =>
      throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) =>
      throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(ValueFailure<T> value, $Res Function(ValueFailure<T>) then) = _$ValueFailureCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res> implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  final ValueFailure<T> _value;

  // ignore: unused_field
  final $Res Function(ValueFailure<T>) _then;
}

/// @nodoc
abstract class $NullInputCopyWith<T, $Res> {
  factory $NullInputCopyWith(NullInput<T> value, $Res Function(NullInput<T>) then) = _$NullInputCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$NullInputCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res> implements $NullInputCopyWith<T, $Res> {
  _$NullInputCopyWithImpl(NullInput<T> _value, $Res Function(NullInput<T>) _then) : super(_value, (v) => _then(v as NullInput<T>));

  @override
  NullInput<T> get _value => super._value as NullInput<T>;
}

/// @nodoc
class _$NullInput<T> implements NullInput<T> {
  const _$NullInput();

  @override
  String toString() {
    return 'ValueFailure<$T>.nullInput()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NullInput<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;
  
  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) {
    return nullInput();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (nullInput != null) {
      return nullInput();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) {
    return nullInput(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (nullInput != null) {
      return nullInput(this);
    }
    return orElse();
  }
}

abstract class NullInput<T> implements ValueFailure<T> {
  const factory NullInput() = _$NullInput<T>;
}

/// @nodoc
abstract class $InvalidDateCopyWith<T, $Res> {
  factory $InvalidDateCopyWith(InvalidDate<T> value, $Res Function(InvalidDate<T>) then) = _$InvalidDateCopyWithImpl<T, $Res>;

  $Res call({DateTime failedValue});
}

/// @nodoc
class _$InvalidDateCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res> implements $InvalidDateCopyWith<T, $Res> {
  _$InvalidDateCopyWithImpl(InvalidDate<T> _value, $Res Function(InvalidDate<T>) _then) : super(_value, (v) => _then(v as InvalidDate<T>));

  @override
  InvalidDate<T> get _value => super._value as InvalidDate<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidDate<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
class _$InvalidDate<T> implements InvalidDate<T> {
  const _$InvalidDate({required this.failedValue});

  @override
  final DateTime failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidDate(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidDate<T> && (identical(other.failedValue, failedValue) || const DeepCollectionEquality().equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode => runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidDateCopyWith<T, InvalidDate<T>> get copyWith => _$InvalidDateCopyWithImpl<T, InvalidDate<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) {
    return invalidDate(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (invalidDate != null) {
      return invalidDate(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) {
    return invalidDate(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (invalidDate != null) {
      return invalidDate(this);
    }
    return orElse();
  }
}

abstract class InvalidDate<T> implements ValueFailure<T> {
  const factory InvalidDate({required DateTime failedValue}) = _$InvalidDate<T>;

  DateTime get failedValue => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $InvalidDateCopyWith<T, InvalidDate<T>> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidEmailCopyWith<T, $Res> {
  factory $InvalidEmailCopyWith(InvalidEmail<T> value, $Res Function(InvalidEmail<T>) then) = _$InvalidEmailCopyWithImpl<T, $Res>;

  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidEmailCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res> implements $InvalidEmailCopyWith<T, $Res> {
  _$InvalidEmailCopyWithImpl(InvalidEmail<T> _value, $Res Function(InvalidEmail<T>) _then) : super(_value, (v) => _then(v as InvalidEmail<T>));

  @override
  InvalidEmail<T> get _value => super._value as InvalidEmail<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidEmail<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
class _$InvalidEmail<T> implements InvalidEmail<T> {
  const _$InvalidEmail({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidEmail(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidEmail<T> && (identical(other.failedValue, failedValue) || const DeepCollectionEquality().equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode => runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith => _$InvalidEmailCopyWithImpl<T, InvalidEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) {
    return invalidEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) {
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail<T> implements ValueFailure<T> {
  const factory InvalidEmail({required String failedValue}) = _$InvalidEmail<T>;

  String get failedValue => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidPasswordCopyWith<T, $Res> {
  factory $InvalidPasswordCopyWith(InvalidPassword<T> value, $Res Function(InvalidPassword<T>) then) = _$InvalidPasswordCopyWithImpl<T, $Res>;

  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidPasswordCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res> implements $InvalidPasswordCopyWith<T, $Res> {
  _$InvalidPasswordCopyWithImpl(InvalidPassword<T> _value, $Res Function(InvalidPassword<T>) _then) : super(_value, (v) => _then(v as InvalidPassword<T>));

  @override
  InvalidPassword<T> get _value => super._value as InvalidPassword<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidPassword<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
class _$InvalidPassword<T> implements InvalidPassword<T> {
  const _$InvalidPassword({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidPassword(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidPassword<T> && (identical(other.failedValue, failedValue) || const DeepCollectionEquality().equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode => runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidPasswordCopyWith<T, InvalidPassword<T>> get copyWith => _$InvalidPasswordCopyWithImpl<T, InvalidPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) {
    return invalidPassword(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (invalidPassword != null) {
      return invalidPassword(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) {
    return invalidPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (invalidPassword != null) {
      return invalidPassword(this);
    }
    return orElse();
  }
}

abstract class InvalidPassword<T> implements ValueFailure<T> {
  const factory InvalidPassword({required String failedValue}) = _$InvalidPassword<T>;

  String get failedValue => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $InvalidPasswordCopyWith<T, InvalidPassword<T>> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StringMismatchCopyWith<T, $Res> {
  factory $StringMismatchCopyWith(StringMismatch<T> value, $Res Function(StringMismatch<T>) then) = _$StringMismatchCopyWithImpl<T, $Res>;

  $Res call({String failedValue});
}

/// @nodoc
class _$StringMismatchCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res> implements $StringMismatchCopyWith<T, $Res> {
  _$StringMismatchCopyWithImpl(StringMismatch<T> _value, $Res Function(StringMismatch<T>) _then) : super(_value, (v) => _then(v as StringMismatch<T>));

  @override
  StringMismatch<T> get _value => super._value as StringMismatch<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(StringMismatch<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
class _$StringMismatch<T> implements StringMismatch<T> {
  const _$StringMismatch({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.stringMismatch(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is StringMismatch<T> && (identical(other.failedValue, failedValue) || const DeepCollectionEquality().equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode => runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $StringMismatchCopyWith<T, StringMismatch<T>> get copyWith => _$StringMismatchCopyWithImpl<T, StringMismatch<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) {
    return stringMismatch(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (stringMismatch != null) {
      return stringMismatch(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) {
    return stringMismatch(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (stringMismatch != null) {
      return stringMismatch(this);
    }
    return orElse();
  }
}

abstract class StringMismatch<T> implements ValueFailure<T> {
  const factory StringMismatch({required String failedValue}) = _$StringMismatch<T>;

  String get failedValue => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StringMismatchCopyWith<T, StringMismatch<T>> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidNameCopyWith<T, $Res> {
  factory $InvalidNameCopyWith(InvalidName<T> value, $Res Function(InvalidName<T>) then) = _$InvalidNameCopyWithImpl<T, $Res>;

  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidNameCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res> implements $InvalidNameCopyWith<T, $Res> {
  _$InvalidNameCopyWithImpl(InvalidName<T> _value, $Res Function(InvalidName<T>) _then) : super(_value, (v) => _then(v as InvalidName<T>));

  @override
  InvalidName<T> get _value => super._value as InvalidName<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidName<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
class _$InvalidName<T> implements InvalidName<T> {
  const _$InvalidName({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidName<T> && (identical(other.failedValue, failedValue) || const DeepCollectionEquality().equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode => runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidNameCopyWith<T, InvalidName<T>> get copyWith => _$InvalidNameCopyWithImpl<T, InvalidName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) {
    return invalidName(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (invalidName != null) {
      return invalidName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) {
    return invalidName(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (invalidName != null) {
      return invalidName(this);
    }
    return orElse();
  }
}

abstract class InvalidName<T> implements ValueFailure<T> {
  const factory InvalidName({required String failedValue}) = _$InvalidName<T>;

  String get failedValue => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $InvalidNameCopyWith<T, InvalidName<T>> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmptyStringCopyWith<T, $Res> {
  factory $EmptyStringCopyWith(EmptyString<T> value, $Res Function(EmptyString<T>) then) = _$EmptyStringCopyWithImpl<T, $Res>;

  $Res call({String failedValue});
}

/// @nodoc
class _$EmptyStringCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res> implements $EmptyStringCopyWith<T, $Res> {
  _$EmptyStringCopyWithImpl(EmptyString<T> _value, $Res Function(EmptyString<T>) _then) : super(_value, (v) => _then(v as EmptyString<T>));

  @override
  EmptyString<T> get _value => super._value as EmptyString<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(EmptyString<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
class _$EmptyString<T> implements EmptyString<T> {
  const _$EmptyString({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.emptyString(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is EmptyString<T> && (identical(other.failedValue, failedValue) || const DeepCollectionEquality().equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode => runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $EmptyStringCopyWith<T, EmptyString<T>> get copyWith => _$EmptyStringCopyWithImpl<T, EmptyString<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) {
    return emptyString(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (emptyString != null) {
      return emptyString(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) {
    return emptyString(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (emptyString != null) {
      return emptyString(this);
    }
    return orElse();
  }
}

abstract class EmptyString<T> implements ValueFailure<T> {
  const factory EmptyString({required String failedValue}) = _$EmptyString<T>;

  String get failedValue => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EmptyStringCopyWith<T, EmptyString<T>> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MultiLineStringCopyWith<T, $Res> {
  factory $MultiLineStringCopyWith(MultiLineString<T> value, $Res Function(MultiLineString<T>) then) = _$MultiLineStringCopyWithImpl<T, $Res>;

  $Res call({String failedValue});
}

/// @nodoc
class _$MultiLineStringCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res> implements $MultiLineStringCopyWith<T, $Res> {
  _$MultiLineStringCopyWithImpl(MultiLineString<T> _value, $Res Function(MultiLineString<T>) _then) : super(_value, (v) => _then(v as MultiLineString<T>));

  @override
  MultiLineString<T> get _value => super._value as MultiLineString<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(MultiLineString<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
class _$MultiLineString<T> implements MultiLineString<T> {
  const _$MultiLineString({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.multiLineString(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is MultiLineString<T> && (identical(other.failedValue, failedValue) || const DeepCollectionEquality().equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode => runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $MultiLineStringCopyWith<T, MultiLineString<T>> get copyWith => _$MultiLineStringCopyWithImpl<T, MultiLineString<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) {
    return multiLineString(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (multiLineString != null) {
      return multiLineString(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) {
    return multiLineString(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (multiLineString != null) {
      return multiLineString(this);
    }
    return orElse();
  }
}

abstract class MultiLineString<T> implements ValueFailure<T> {
  const factory MultiLineString({required String failedValue}) = _$MultiLineString<T>;

  String get failedValue => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MultiLineStringCopyWith<T, MultiLineString<T>> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StringExceedsLengthCopyWith<T, $Res> {
  factory $StringExceedsLengthCopyWith(StringExceedsLength<T> value, $Res Function(StringExceedsLength<T>) then) = _$StringExceedsLengthCopyWithImpl<T, $Res>;

  $Res call({String failedValue, int maxLength});
}

/// @nodoc
class _$StringExceedsLengthCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res> implements $StringExceedsLengthCopyWith<T, $Res> {
  _$StringExceedsLengthCopyWithImpl(StringExceedsLength<T> _value, $Res Function(StringExceedsLength<T>) _then) : super(_value, (v) => _then(v as StringExceedsLength<T>));

  @override
  StringExceedsLength<T> get _value => super._value as StringExceedsLength<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
    Object? maxLength = freezed,
  }) {
    return _then(StringExceedsLength<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
      maxLength: maxLength == freezed
          ? _value.maxLength
          : maxLength // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
class _$StringExceedsLength<T> implements StringExceedsLength<T> {
  const _$StringExceedsLength({required this.failedValue, required this.maxLength});

  @override
  final String failedValue;
  @override
  final int maxLength;

  @override
  String toString() {
    return 'ValueFailure<$T>.stringExceedsLength(failedValue: $failedValue, maxLength: $maxLength)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StringExceedsLength<T> &&
            (identical(other.failedValue, failedValue) || const DeepCollectionEquality().equals(other.failedValue, failedValue)) &&
            (identical(other.maxLength, maxLength) || const DeepCollectionEquality().equals(other.maxLength, maxLength)));
  }

  @override
  int get hashCode => runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue) ^ const DeepCollectionEquality().hash(maxLength);

  @JsonKey(ignore: true)
  @override
  $StringExceedsLengthCopyWith<T, StringExceedsLength<T>> get copyWith => _$StringExceedsLengthCopyWithImpl<T, StringExceedsLength<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) {
    return stringExceedsLength(failedValue, maxLength);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (stringExceedsLength != null) {
      return stringExceedsLength(failedValue, maxLength);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) {
    return stringExceedsLength(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (stringExceedsLength != null) {
      return stringExceedsLength(this);
    }
    return orElse();
  }
}

abstract class StringExceedsLength<T> implements ValueFailure<T> {
  const factory StringExceedsLength({required String failedValue, required int maxLength}) = _$StringExceedsLength<T>;

  String get failedValue => throw _privateConstructorUsedError;

  int get maxLength => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StringExceedsLengthCopyWith<T, StringExceedsLength<T>> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IntegerOutOfBoundsCopyWith<T, $Res> {
  factory $IntegerOutOfBoundsCopyWith(IntegerOutOfBounds<T> value, $Res Function(IntegerOutOfBounds<T>) then) = _$IntegerOutOfBoundsCopyWithImpl<T, $Res>;

  $Res call({int failedValue});
}

/// @nodoc
class _$IntegerOutOfBoundsCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res> implements $IntegerOutOfBoundsCopyWith<T, $Res> {
  _$IntegerOutOfBoundsCopyWithImpl(IntegerOutOfBounds<T> _value, $Res Function(IntegerOutOfBounds<T>) _then) : super(_value, (v) => _then(v as IntegerOutOfBounds<T>));

  @override
  IntegerOutOfBounds<T> get _value => super._value as IntegerOutOfBounds<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(IntegerOutOfBounds<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
class _$IntegerOutOfBounds<T> implements IntegerOutOfBounds<T> {
  const _$IntegerOutOfBounds({required this.failedValue});

  @override
  final int failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.integerOutOfBounds(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is IntegerOutOfBounds<T> && (identical(other.failedValue, failedValue) || const DeepCollectionEquality().equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode => runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $IntegerOutOfBoundsCopyWith<T, IntegerOutOfBounds<T>> get copyWith => _$IntegerOutOfBoundsCopyWithImpl<T, IntegerOutOfBounds<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) {
    return integerOutOfBounds(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (integerOutOfBounds != null) {
      return integerOutOfBounds(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) {
    return integerOutOfBounds(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (integerOutOfBounds != null) {
      return integerOutOfBounds(this);
    }
    return orElse();
  }
}

abstract class IntegerOutOfBounds<T> implements ValueFailure<T> {
  const factory IntegerOutOfBounds({required int failedValue}) = _$IntegerOutOfBounds<T>;

  int get failedValue => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $IntegerOutOfBoundsCopyWith<T, IntegerOutOfBounds<T>> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StringWithInvalidCharactersCopyWith<T, $Res> {
  factory $StringWithInvalidCharactersCopyWith(StringWithInvalidCharacters<T> value, $Res Function(StringWithInvalidCharacters<T>) then) = _$StringWithInvalidCharactersCopyWithImpl<T, $Res>;

  $Res call({String failedValue});
}

/// @nodoc
class _$StringWithInvalidCharactersCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res> implements $StringWithInvalidCharactersCopyWith<T, $Res> {
  _$StringWithInvalidCharactersCopyWithImpl(StringWithInvalidCharacters<T> _value, $Res Function(StringWithInvalidCharacters<T>) _then)
      : super(_value, (v) => _then(v as StringWithInvalidCharacters<T>));

  @override
  StringWithInvalidCharacters<T> get _value => super._value as StringWithInvalidCharacters<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(StringWithInvalidCharacters<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
class _$StringWithInvalidCharacters<T> implements StringWithInvalidCharacters<T> {
  const _$StringWithInvalidCharacters({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.stringWithInvalidCharacters(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is StringWithInvalidCharacters<T> && (identical(other.failedValue, failedValue) || const DeepCollectionEquality().equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode => runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $StringWithInvalidCharactersCopyWith<T, StringWithInvalidCharacters<T>> get copyWith => _$StringWithInvalidCharactersCopyWithImpl<T, StringWithInvalidCharacters<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) {
    return stringWithInvalidCharacters(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (stringWithInvalidCharacters != null) {
      return stringWithInvalidCharacters(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) {
    return stringWithInvalidCharacters(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (stringWithInvalidCharacters != null) {
      return stringWithInvalidCharacters(this);
    }
    return orElse();
  }
}

abstract class StringWithInvalidCharacters<T> implements ValueFailure<T> {
  const factory StringWithInvalidCharacters({required String failedValue}) = _$StringWithInvalidCharacters<T>;

  String get failedValue => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StringWithInvalidCharactersCopyWith<T, StringWithInvalidCharacters<T>> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidCoordinatesCopyWith<T, $Res> {
  factory $InvalidCoordinatesCopyWith(InvalidCoordinates<T> value, $Res Function(InvalidCoordinates<T>) then) = _$InvalidCoordinatesCopyWithImpl<T, $Res>;

  $Res call({double failedValue});
}

/// @nodoc
class _$InvalidCoordinatesCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res> implements $InvalidCoordinatesCopyWith<T, $Res> {
  _$InvalidCoordinatesCopyWithImpl(InvalidCoordinates<T> _value, $Res Function(InvalidCoordinates<T>) _then) : super(_value, (v) => _then(v as InvalidCoordinates<T>));

  @override
  InvalidCoordinates<T> get _value => super._value as InvalidCoordinates<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidCoordinates<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
class _$InvalidCoordinates<T> implements InvalidCoordinates<T> {
  const _$InvalidCoordinates({required this.failedValue});

  @override
  final double failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidCoordinate(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidCoordinates<T> && (identical(other.failedValue, failedValue) || const DeepCollectionEquality().equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode => runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidCoordinatesCopyWith<T, InvalidCoordinates<T>> get copyWith => _$InvalidCoordinatesCopyWithImpl<T, InvalidCoordinates<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) {
    return invalidCoordinate(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (invalidCoordinate != null) {
      return invalidCoordinate(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) {
    return invalidCoordinate(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (invalidCoordinate != null) {
      return invalidCoordinate(this);
    }
    return orElse();
  }
}

abstract class InvalidCoordinates<T> implements ValueFailure<T> {
  const factory InvalidCoordinates({required double failedValue}) = _$InvalidCoordinates<T>;

  double get failedValue => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $InvalidCoordinatesCopyWith<T, InvalidCoordinates<T>> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmptySetCopyWith<T, $Res> {
  factory $EmptySetCopyWith(EmptySet<T> value, $Res Function(EmptySet<T>) then) = _$EmptySetCopyWithImpl<T, $Res>;

  $Res call({T failedValue});
}

/// @nodoc
class _$EmptySetCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res> implements $EmptySetCopyWith<T, $Res> {
  _$EmptySetCopyWithImpl(EmptySet<T> _value, $Res Function(EmptySet<T>) _then) : super(_value, (v) => _then(v as EmptySet<T>));

  @override
  EmptySet<T> get _value => super._value as EmptySet<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(EmptySet<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc
class _$EmptySet<T> implements EmptySet<T> {
  const _$EmptySet({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.emptySet(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is EmptySet<T> && (identical(other.failedValue, failedValue) || const DeepCollectionEquality().equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode => runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $EmptySetCopyWith<T, EmptySet<T>> get copyWith => _$EmptySetCopyWithImpl<T, EmptySet<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) {
    return emptySet(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (emptySet != null) {
      return emptySet(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) {
    return emptySet(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (emptySet != null) {
      return emptySet(this);
    }
    return orElse();
  }
}

abstract class EmptySet<T> implements ValueFailure<T> {
  const factory EmptySet({required T failedValue}) = _$EmptySet<T>;

  T get failedValue => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EmptySetCopyWith<T, EmptySet<T>> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmptyListCopyWith<T, $Res> {
  factory $EmptyListCopyWith(EmptyList<T> value, $Res Function(EmptyList<T>) then) = _$EmptyListCopyWithImpl<T, $Res>;

  $Res call({T failedValue});
}

/// @nodoc
class _$EmptyListCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res> implements $EmptyListCopyWith<T, $Res> {
  _$EmptyListCopyWithImpl(EmptyList<T> _value, $Res Function(EmptyList<T>) _then) : super(_value, (v) => _then(v as EmptyList<T>));

  @override
  EmptyList<T> get _value => super._value as EmptyList<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(EmptyList<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc
class _$EmptyList<T> implements EmptyList<T> {
  const _$EmptyList({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.emptyList(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is EmptyList<T> && (identical(other.failedValue, failedValue) || const DeepCollectionEquality().equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode => runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $EmptyListCopyWith<T, EmptyList<T>> get copyWith => _$EmptyListCopyWithImpl<T, EmptyList<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) {
    return emptyList(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (emptyList != null) {
      return emptyList(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) {
    return emptyList(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (emptyList != null) {
      return emptyList(this);
    }
    return orElse();
  }
}

abstract class EmptyList<T> implements ValueFailure<T> {
  const factory EmptyList({required T failedValue}) = _$EmptyList<T>;

  T get failedValue => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EmptyListCopyWith<T, EmptyList<T>> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CollectionExceedsLengthCopyWith<T, $Res> {
  factory $CollectionExceedsLengthCopyWith(CollectionExceedsLength<T> value, $Res Function(CollectionExceedsLength<T>) then) = _$CollectionExceedsLengthCopyWithImpl<T, $Res>;

  $Res call({T failedValue, int maxLength});
}

/// @nodoc
class _$CollectionExceedsLengthCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res> implements $CollectionExceedsLengthCopyWith<T, $Res> {
  _$CollectionExceedsLengthCopyWithImpl(CollectionExceedsLength<T> _value, $Res Function(CollectionExceedsLength<T>) _then) : super(_value, (v) => _then(v as CollectionExceedsLength<T>));

  @override
  CollectionExceedsLength<T> get _value => super._value as CollectionExceedsLength<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
    Object? maxLength = freezed,
  }) {
    return _then(CollectionExceedsLength<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
      maxLength: maxLength == freezed
          ? _value.maxLength
          : maxLength // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
class _$CollectionExceedsLength<T> implements CollectionExceedsLength<T> {
  const _$CollectionExceedsLength({required this.failedValue, required this.maxLength});

  @override
  final T failedValue;
  @override
  final int maxLength;

  @override
  String toString() {
    return 'ValueFailure<$T>.collectionExceedsLength(failedValue: $failedValue, maxLength: $maxLength)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CollectionExceedsLength<T> &&
            (identical(other.failedValue, failedValue) || const DeepCollectionEquality().equals(other.failedValue, failedValue)) &&
            (identical(other.maxLength, maxLength) || const DeepCollectionEquality().equals(other.maxLength, maxLength)));
  }
  
  @override
  int get hashCode => runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue) ^ const DeepCollectionEquality().hash(maxLength);

  @JsonKey(ignore: true)
  @override
  $CollectionExceedsLengthCopyWith<T, CollectionExceedsLength<T>> get copyWith => _$CollectionExceedsLengthCopyWithImpl<T, CollectionExceedsLength<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nullInput,
    required TResult Function(DateTime failedValue) invalidDate,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) invalidPassword,
    required TResult Function(String failedValue) stringMismatch,
    required TResult Function(String failedValue) invalidName,
    required TResult Function(String failedValue) emptyString,
    required TResult Function(String failedValue) multiLineString,
    required TResult Function(String failedValue, int maxLength) stringExceedsLength,
    required TResult Function(int failedValue) integerOutOfBounds,
    required TResult Function(String failedValue) stringWithInvalidCharacters,
    required TResult Function(double failedValue) invalidCoordinate,
    required TResult Function(T failedValue) emptySet,
    required TResult Function(T failedValue) emptyList,
    required TResult Function(T failedValue, int maxLength) collectionExceedsLength,
  }) {
    return collectionExceedsLength(failedValue, maxLength);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nullInput,
    TResult Function(DateTime failedValue)? invalidDate,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? invalidPassword,
    TResult Function(String failedValue)? stringMismatch,
    TResult Function(String failedValue)? invalidName,
    TResult Function(String failedValue)? emptyString,
    TResult Function(String failedValue)? multiLineString,
    TResult Function(String failedValue, int maxLength)? stringExceedsLength,
    TResult Function(int failedValue)? integerOutOfBounds,
    TResult Function(String failedValue)? stringWithInvalidCharacters,
    TResult Function(double failedValue)? invalidCoordinate,
    TResult Function(T failedValue)? emptySet,
    TResult Function(T failedValue)? emptyList,
    TResult Function(T failedValue, int maxLength)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (collectionExceedsLength != null) {
      return collectionExceedsLength(failedValue, maxLength);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullInput<T> value) nullInput,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidPassword<T> value) invalidPassword,
    required TResult Function(StringMismatch<T> value) stringMismatch,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(EmptyString<T> value) emptyString,
    required TResult Function(MultiLineString<T> value) multiLineString,
    required TResult Function(StringExceedsLength<T> value) stringExceedsLength,
    required TResult Function(IntegerOutOfBounds<T> value) integerOutOfBounds,
    required TResult Function(StringWithInvalidCharacters<T> value) stringWithInvalidCharacters,
    required TResult Function(InvalidCoordinates<T> value) invalidCoordinate,
    required TResult Function(EmptySet<T> value) emptySet,
    required TResult Function(EmptyList<T> value) emptyList,
    required TResult Function(CollectionExceedsLength<T> value) collectionExceedsLength,
  }) {
    return collectionExceedsLength(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullInput<T> value)? nullInput,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidPassword<T> value)? invalidPassword,
    TResult Function(StringMismatch<T> value)? stringMismatch,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(EmptyString<T> value)? emptyString,
    TResult Function(MultiLineString<T> value)? multiLineString,
    TResult Function(StringExceedsLength<T> value)? stringExceedsLength,
    TResult Function(IntegerOutOfBounds<T> value)? integerOutOfBounds,
    TResult Function(StringWithInvalidCharacters<T> value)? stringWithInvalidCharacters,
    TResult Function(InvalidCoordinates<T> value)? invalidCoordinate,
    TResult Function(EmptySet<T> value)? emptySet,
    TResult Function(EmptyList<T> value)? emptyList,
    TResult Function(CollectionExceedsLength<T> value)? collectionExceedsLength,
    required TResult orElse(),
  }) {
    if (collectionExceedsLength != null) {
      return collectionExceedsLength(this);
    }
    return orElse();
  }
}

abstract class CollectionExceedsLength<T> implements ValueFailure<T> {
  const factory CollectionExceedsLength({required T failedValue, required int maxLength}) = _$CollectionExceedsLength<T>;

  T get failedValue => throw _privateConstructorUsedError;

  int get maxLength => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CollectionExceedsLengthCopyWith<T, CollectionExceedsLength<T>> get copyWith => throw _privateConstructorUsedError;
}
