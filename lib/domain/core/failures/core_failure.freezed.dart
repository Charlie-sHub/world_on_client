// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'core_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$CoreFailureTearOff {
  const _$CoreFailureTearOff();

  UnknownDomainLayerError unknownDomainLayerError() {
    return const UnknownDomainLayerError();
  }

  ServerError serverError() {
    return const ServerError();
  }

  NotFoundError notFoundError() {
    return const NotFoundError();
  }

  CacheError cacheError() {
    return const CacheError();
  }

  GeoLocationError geoLocationError() {
    return const GeoLocationError();
  }

  UsernameAlreadyInUse usernameAlreadyInUse() {
    return const UsernameAlreadyInUse();
  }

  UnAuthorizedError unAuthorizedError() {
    return const UnAuthorizedError();
  }

  NameAlreadyInUse nameAlreadyInUse() {
    return const NameAlreadyInUse();
  }
}

// ignore: unused_element
const $CoreFailure = _$CoreFailureTearOff();

mixin _$CoreFailure {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result unknownDomainLayerError(),
    @required Result serverError(),
    @required Result notFoundError(),
    @required Result cacheError(),
    @required Result geoLocationError(),
    @required Result usernameAlreadyInUse(),
    @required Result unAuthorizedError(),
    @required Result nameAlreadyInUse(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result unknownDomainLayerError(),
    Result serverError(),
    Result notFoundError(),
    Result cacheError(),
    Result geoLocationError(),
    Result usernameAlreadyInUse(),
    Result unAuthorizedError(),
    Result nameAlreadyInUse(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result unknownDomainLayerError(UnknownDomainLayerError value),
    @required Result serverError(ServerError value),
    @required Result notFoundError(NotFoundError value),
    @required Result cacheError(CacheError value),
    @required Result geoLocationError(GeoLocationError value),
    @required Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    @required Result unAuthorizedError(UnAuthorizedError value),
    @required Result nameAlreadyInUse(NameAlreadyInUse value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result unknownDomainLayerError(UnknownDomainLayerError value),
    Result serverError(ServerError value),
    Result notFoundError(NotFoundError value),
    Result cacheError(CacheError value),
    Result geoLocationError(GeoLocationError value),
    Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    Result unAuthorizedError(UnAuthorizedError value),
    Result nameAlreadyInUse(NameAlreadyInUse value),
    @required Result orElse(),
  });
}

abstract class $CoreFailureCopyWith<$Res> {
  factory $CoreFailureCopyWith(CoreFailure value, $Res Function(CoreFailure) then) = _$CoreFailureCopyWithImpl<$Res>;
}

class _$CoreFailureCopyWithImpl<$Res> implements $CoreFailureCopyWith<$Res> {
  _$CoreFailureCopyWithImpl(this._value, this._then);

  final CoreFailure _value;
  // ignore: unused_field
  final $Res Function(CoreFailure) _then;
}

abstract class $UnknownDomainLayerErrorCopyWith<$Res> {
  factory $UnknownDomainLayerErrorCopyWith(UnknownDomainLayerError value,
    $Res Function(UnknownDomainLayerError) then) =
  _$UnknownDomainLayerErrorCopyWithImpl<$Res>;
}

class _$UnknownDomainLayerErrorCopyWithImpl<$Res> extends _$CoreFailureCopyWithImpl<$Res>
  implements $UnknownDomainLayerErrorCopyWith<$Res> {
  _$UnknownDomainLayerErrorCopyWithImpl(UnknownDomainLayerError _value,
    $Res Function(UnknownDomainLayerError) _then)
    : super(_value, (v) => _then(v as UnknownDomainLayerError));

  @override
  UnknownDomainLayerError get _value => super._value as UnknownDomainLayerError;
}

class _$UnknownDomainLayerError
  with DiagnosticableTreeMixin
  implements UnknownDomainLayerError {
  const _$UnknownDomainLayerError();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CoreFailure.unknownDomainLayerError()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CoreFailure.unknownDomainLayerError'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UnknownDomainLayerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result unknownDomainLayerError(),
    @required Result serverError(),
    @required Result notFoundError(),
    @required Result cacheError(),
    @required Result geoLocationError(),
    @required Result usernameAlreadyInUse(),
    @required Result unAuthorizedError(),
    @required Result nameAlreadyInUse(),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return unknownDomainLayerError();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result unknownDomainLayerError(),
    Result serverError(),
    Result notFoundError(),
    Result cacheError(),
    Result geoLocationError(),
    Result usernameAlreadyInUse(),
    Result unAuthorizedError(),
    Result nameAlreadyInUse(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (unknownDomainLayerError != null) {
      return unknownDomainLayerError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result unknownDomainLayerError(UnknownDomainLayerError value),
    @required Result serverError(ServerError value),
    @required Result notFoundError(NotFoundError value),
    @required Result cacheError(CacheError value),
    @required Result geoLocationError(GeoLocationError value),
    @required Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    @required Result unAuthorizedError(UnAuthorizedError value),
    @required Result nameAlreadyInUse(NameAlreadyInUse value),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return unknownDomainLayerError(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result unknownDomainLayerError(UnknownDomainLayerError value),
    Result serverError(ServerError value),
    Result notFoundError(NotFoundError value),
    Result cacheError(CacheError value),
    Result geoLocationError(GeoLocationError value),
    Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    Result unAuthorizedError(UnAuthorizedError value),
    Result nameAlreadyInUse(NameAlreadyInUse value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (unknownDomainLayerError != null) {
      return unknownDomainLayerError(this);
    }
    return orElse();
  }
}

abstract class UnknownDomainLayerError implements CoreFailure {
  const factory UnknownDomainLayerError() = _$UnknownDomainLayerError;
}

abstract class $ServerErrorCopyWith<$Res> {
  factory $ServerErrorCopyWith(ServerError value, $Res Function(ServerError) then) =
  _$ServerErrorCopyWithImpl<$Res>;
}

class _$ServerErrorCopyWithImpl<$Res> extends _$CoreFailureCopyWithImpl<$Res>
  implements $ServerErrorCopyWith<$Res> {
  _$ServerErrorCopyWithImpl(ServerError _value, $Res Function(ServerError) _then)
    : super(_value, (v) => _then(v as ServerError));

  @override
  ServerError get _value => super._value as ServerError;
}

class _$ServerError with DiagnosticableTreeMixin implements ServerError {
  const _$ServerError();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CoreFailure.serverError()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'CoreFailure.serverError'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ServerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result unknownDomainLayerError(),
    @required Result serverError(),
    @required Result notFoundError(),
    @required Result cacheError(),
    @required Result geoLocationError(),
    @required Result usernameAlreadyInUse(),
    @required Result unAuthorizedError(),
    @required Result nameAlreadyInUse(),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return serverError();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result unknownDomainLayerError(),
    Result serverError(),
    Result notFoundError(),
    Result cacheError(),
    Result geoLocationError(),
    Result usernameAlreadyInUse(),
    Result unAuthorizedError(),
    Result nameAlreadyInUse(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result unknownDomainLayerError(UnknownDomainLayerError value),
    @required Result serverError(ServerError value),
    @required Result notFoundError(NotFoundError value),
    @required Result cacheError(CacheError value),
    @required Result geoLocationError(GeoLocationError value),
    @required Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    @required Result unAuthorizedError(UnAuthorizedError value),
    @required Result nameAlreadyInUse(NameAlreadyInUse value),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result unknownDomainLayerError(UnknownDomainLayerError value),
    Result serverError(ServerError value),
    Result notFoundError(NotFoundError value),
    Result cacheError(CacheError value),
    Result geoLocationError(GeoLocationError value),
    Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    Result unAuthorizedError(UnAuthorizedError value),
    Result nameAlreadyInUse(NameAlreadyInUse value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class ServerError implements CoreFailure {
  const factory ServerError() = _$ServerError;
}

abstract class $NotFoundErrorCopyWith<$Res> {
  factory $NotFoundErrorCopyWith(NotFoundError value, $Res Function(NotFoundError) then) =
  _$NotFoundErrorCopyWithImpl<$Res>;
}

class _$NotFoundErrorCopyWithImpl<$Res> extends _$CoreFailureCopyWithImpl<$Res>
  implements $NotFoundErrorCopyWith<$Res> {
  _$NotFoundErrorCopyWithImpl(NotFoundError _value, $Res Function(NotFoundError) _then)
    : super(_value, (v) => _then(v as NotFoundError));

  @override
  NotFoundError get _value => super._value as NotFoundError;
}

class _$NotFoundError with DiagnosticableTreeMixin implements NotFoundError {
  const _$NotFoundError();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CoreFailure.notFoundError()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'CoreFailure.notFoundError'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NotFoundError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result unknownDomainLayerError(),
    @required Result serverError(),
    @required Result notFoundError(),
    @required Result cacheError(),
    @required Result geoLocationError(),
    @required Result usernameAlreadyInUse(),
    @required Result unAuthorizedError(),
    @required Result nameAlreadyInUse(),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return notFoundError();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result unknownDomainLayerError(),
    Result serverError(),
    Result notFoundError(),
    Result cacheError(),
    Result geoLocationError(),
    Result usernameAlreadyInUse(),
    Result unAuthorizedError(),
    Result nameAlreadyInUse(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (notFoundError != null) {
      return notFoundError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result unknownDomainLayerError(UnknownDomainLayerError value),
    @required Result serverError(ServerError value),
    @required Result notFoundError(NotFoundError value),
    @required Result cacheError(CacheError value),
    @required Result geoLocationError(GeoLocationError value),
    @required Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    @required Result unAuthorizedError(UnAuthorizedError value),
    @required Result nameAlreadyInUse(NameAlreadyInUse value),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return notFoundError(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result unknownDomainLayerError(UnknownDomainLayerError value),
    Result serverError(ServerError value),
    Result notFoundError(NotFoundError value),
    Result cacheError(CacheError value),
    Result geoLocationError(GeoLocationError value),
    Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    Result unAuthorizedError(UnAuthorizedError value),
    Result nameAlreadyInUse(NameAlreadyInUse value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (notFoundError != null) {
      return notFoundError(this);
    }
    return orElse();
  }
}

abstract class NotFoundError implements CoreFailure {
  const factory NotFoundError() = _$NotFoundError;
}

abstract class $CacheErrorCopyWith<$Res> {
  factory $CacheErrorCopyWith(CacheError value, $Res Function(CacheError) then) =
  _$CacheErrorCopyWithImpl<$Res>;
}

class _$CacheErrorCopyWithImpl<$Res> extends _$CoreFailureCopyWithImpl<$Res>
  implements $CacheErrorCopyWith<$Res> {
  _$CacheErrorCopyWithImpl(CacheError _value, $Res Function(CacheError) _then)
    : super(_value, (v) => _then(v as CacheError));

  @override
  CacheError get _value => super._value as CacheError;
}

class _$CacheError with DiagnosticableTreeMixin implements CacheError {
  const _$CacheError();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CoreFailure.cacheError()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'CoreFailure.cacheError'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is CacheError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result unknownDomainLayerError(),
    @required Result serverError(),
    @required Result notFoundError(),
    @required Result cacheError(),
    @required Result geoLocationError(),
    @required Result usernameAlreadyInUse(),
    @required Result unAuthorizedError(),
    @required Result nameAlreadyInUse(),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return cacheError();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result unknownDomainLayerError(),
    Result serverError(),
    Result notFoundError(),
    Result cacheError(),
    Result geoLocationError(),
    Result usernameAlreadyInUse(),
    Result unAuthorizedError(),
    Result nameAlreadyInUse(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (cacheError != null) {
      return cacheError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result unknownDomainLayerError(UnknownDomainLayerError value),
    @required Result serverError(ServerError value),
    @required Result notFoundError(NotFoundError value),
    @required Result cacheError(CacheError value),
    @required Result geoLocationError(GeoLocationError value),
    @required Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    @required Result unAuthorizedError(UnAuthorizedError value),
    @required Result nameAlreadyInUse(NameAlreadyInUse value),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return cacheError(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result unknownDomainLayerError(UnknownDomainLayerError value),
    Result serverError(ServerError value),
    Result notFoundError(NotFoundError value),
    Result cacheError(CacheError value),
    Result geoLocationError(GeoLocationError value),
    Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    Result unAuthorizedError(UnAuthorizedError value),
    Result nameAlreadyInUse(NameAlreadyInUse value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (cacheError != null) {
      return cacheError(this);
    }
    return orElse();
  }
}

abstract class CacheError implements CoreFailure {
  const factory CacheError() = _$CacheError;
}

abstract class $GeoLocationErrorCopyWith<$Res> {
  factory $GeoLocationErrorCopyWith(GeoLocationError value, $Res Function(GeoLocationError) then) =
  _$GeoLocationErrorCopyWithImpl<$Res>;
}

class _$GeoLocationErrorCopyWithImpl<$Res> extends _$CoreFailureCopyWithImpl<$Res>
  implements $GeoLocationErrorCopyWith<$Res> {
  _$GeoLocationErrorCopyWithImpl(GeoLocationError _value, $Res Function(GeoLocationError) _then)
    : super(_value, (v) => _then(v as GeoLocationError));

  @override
  GeoLocationError get _value => super._value as GeoLocationError;
}

class _$GeoLocationError
  with DiagnosticableTreeMixin
  implements GeoLocationError {
  const _$GeoLocationError();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CoreFailure.geoLocationError()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CoreFailure.geoLocationError'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is GeoLocationError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result unknownDomainLayerError(),
    @required Result serverError(),
    @required Result notFoundError(),
    @required Result cacheError(),
    @required Result geoLocationError(),
    @required Result usernameAlreadyInUse(),
    @required Result unAuthorizedError(),
    @required Result nameAlreadyInUse(),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return geoLocationError();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result unknownDomainLayerError(),
    Result serverError(),
    Result notFoundError(),
    Result cacheError(),
    Result geoLocationError(),
    Result usernameAlreadyInUse(),
    Result unAuthorizedError(),
    Result nameAlreadyInUse(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (geoLocationError != null) {
      return geoLocationError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result unknownDomainLayerError(UnknownDomainLayerError value),
    @required Result serverError(ServerError value),
    @required Result notFoundError(NotFoundError value),
    @required Result cacheError(CacheError value),
    @required Result geoLocationError(GeoLocationError value),
    @required Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    @required Result unAuthorizedError(UnAuthorizedError value),
    @required Result nameAlreadyInUse(NameAlreadyInUse value),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return geoLocationError(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result unknownDomainLayerError(UnknownDomainLayerError value),
    Result serverError(ServerError value),
    Result notFoundError(NotFoundError value),
    Result cacheError(CacheError value),
    Result geoLocationError(GeoLocationError value),
    Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    Result unAuthorizedError(UnAuthorizedError value),
    Result nameAlreadyInUse(NameAlreadyInUse value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (geoLocationError != null) {
      return geoLocationError(this);
    }
    return orElse();
  }
}

abstract class GeoLocationError implements CoreFailure {
  const factory GeoLocationError() = _$GeoLocationError;
}

abstract class $UsernameAlreadyInUseCopyWith<$Res> {
  factory $UsernameAlreadyInUseCopyWith(UsernameAlreadyInUse value,
    $Res Function(UsernameAlreadyInUse) then) =
  _$UsernameAlreadyInUseCopyWithImpl<$Res>;
}

class _$UsernameAlreadyInUseCopyWithImpl<$Res> extends _$CoreFailureCopyWithImpl<$Res>
  implements $UsernameAlreadyInUseCopyWith<$Res> {
  _$UsernameAlreadyInUseCopyWithImpl(UsernameAlreadyInUse _value, $Res Function(UsernameAlreadyInUse) _then)
    : super(_value, (v) => _then(v as UsernameAlreadyInUse));

  @override
  UsernameAlreadyInUse get _value => super._value as UsernameAlreadyInUse;
}

class _$UsernameAlreadyInUse
  with DiagnosticableTreeMixin
  implements UsernameAlreadyInUse {
  const _$UsernameAlreadyInUse();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CoreFailure.usernameAlreadyInUse()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CoreFailure.usernameAlreadyInUse'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UsernameAlreadyInUse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result unknownDomainLayerError(),
    @required Result serverError(),
    @required Result notFoundError(),
    @required Result cacheError(),
    @required Result geoLocationError(),
    @required Result usernameAlreadyInUse(),
    @required Result unAuthorizedError(),
    @required Result nameAlreadyInUse(),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return usernameAlreadyInUse();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result unknownDomainLayerError(),
    Result serverError(),
    Result notFoundError(),
    Result cacheError(),
    Result geoLocationError(),
    Result usernameAlreadyInUse(),
    Result unAuthorizedError(),
    Result nameAlreadyInUse(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (usernameAlreadyInUse != null) {
      return usernameAlreadyInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result unknownDomainLayerError(UnknownDomainLayerError value),
    @required Result serverError(ServerError value),
    @required Result notFoundError(NotFoundError value),
    @required Result cacheError(CacheError value),
    @required Result geoLocationError(GeoLocationError value),
    @required Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    @required Result unAuthorizedError(UnAuthorizedError value),
    @required Result nameAlreadyInUse(NameAlreadyInUse value),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return usernameAlreadyInUse(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result unknownDomainLayerError(UnknownDomainLayerError value),
    Result serverError(ServerError value),
    Result notFoundError(NotFoundError value),
    Result cacheError(CacheError value),
    Result geoLocationError(GeoLocationError value),
    Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    Result unAuthorizedError(UnAuthorizedError value),
    Result nameAlreadyInUse(NameAlreadyInUse value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (usernameAlreadyInUse != null) {
      return usernameAlreadyInUse(this);
    }
    return orElse();
  }
}

abstract class UsernameAlreadyInUse implements CoreFailure {
  const factory UsernameAlreadyInUse() = _$UsernameAlreadyInUse;
}

abstract class $UnAuthorizedErrorCopyWith<$Res> {
  factory $UnAuthorizedErrorCopyWith(UnAuthorizedError value, $Res Function(UnAuthorizedError) then) =
  _$UnAuthorizedErrorCopyWithImpl<$Res>;
}

class _$UnAuthorizedErrorCopyWithImpl<$Res> extends _$CoreFailureCopyWithImpl<$Res>
  implements $UnAuthorizedErrorCopyWith<$Res> {
  _$UnAuthorizedErrorCopyWithImpl(UnAuthorizedError _value, $Res Function(UnAuthorizedError) _then)
    : super(_value, (v) => _then(v as UnAuthorizedError));

  @override
  UnAuthorizedError get _value => super._value as UnAuthorizedError;
}

class _$UnAuthorizedError
  with DiagnosticableTreeMixin
  implements UnAuthorizedError {
  const _$UnAuthorizedError();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CoreFailure.unAuthorizedError()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CoreFailure.unAuthorizedError'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UnAuthorizedError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result unknownDomainLayerError(),
    @required Result serverError(),
    @required Result notFoundError(),
    @required Result cacheError(),
    @required Result geoLocationError(),
    @required Result usernameAlreadyInUse(),
    @required Result unAuthorizedError(),
    @required Result nameAlreadyInUse(),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return unAuthorizedError();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result unknownDomainLayerError(),
    Result serverError(),
    Result notFoundError(),
    Result cacheError(),
    Result geoLocationError(),
    Result usernameAlreadyInUse(),
    Result unAuthorizedError(),
    Result nameAlreadyInUse(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (unAuthorizedError != null) {
      return unAuthorizedError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result unknownDomainLayerError(UnknownDomainLayerError value),
    @required Result serverError(ServerError value),
    @required Result notFoundError(NotFoundError value),
    @required Result cacheError(CacheError value),
    @required Result geoLocationError(GeoLocationError value),
    @required Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    @required Result unAuthorizedError(UnAuthorizedError value),
    @required Result nameAlreadyInUse(NameAlreadyInUse value),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return unAuthorizedError(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result unknownDomainLayerError(UnknownDomainLayerError value),
    Result serverError(ServerError value),
    Result notFoundError(NotFoundError value),
    Result cacheError(CacheError value),
    Result geoLocationError(GeoLocationError value),
    Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    Result unAuthorizedError(UnAuthorizedError value),
    Result nameAlreadyInUse(NameAlreadyInUse value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (unAuthorizedError != null) {
      return unAuthorizedError(this);
    }
    return orElse();
  }
}

abstract class UnAuthorizedError implements CoreFailure {
  const factory UnAuthorizedError() = _$UnAuthorizedError;
}

abstract class $NameAlreadyInUseCopyWith<$Res> {
  factory $NameAlreadyInUseCopyWith(NameAlreadyInUse value, $Res Function(NameAlreadyInUse) then) =
  _$NameAlreadyInUseCopyWithImpl<$Res>;
}

class _$NameAlreadyInUseCopyWithImpl<$Res> extends _$CoreFailureCopyWithImpl<$Res>
  implements $NameAlreadyInUseCopyWith<$Res> {
  _$NameAlreadyInUseCopyWithImpl(NameAlreadyInUse _value, $Res Function(NameAlreadyInUse) _then)
    : super(_value, (v) => _then(v as NameAlreadyInUse));

  @override
  NameAlreadyInUse get _value => super._value as NameAlreadyInUse;
}

class _$NameAlreadyInUse
  with DiagnosticableTreeMixin
  implements NameAlreadyInUse {
  const _$NameAlreadyInUse();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CoreFailure.nameAlreadyInUse()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CoreFailure.nameAlreadyInUse'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NameAlreadyInUse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result unknownDomainLayerError(),
    @required Result serverError(),
    @required Result notFoundError(),
    @required Result cacheError(),
    @required Result geoLocationError(),
    @required Result usernameAlreadyInUse(),
    @required Result unAuthorizedError(),
    @required Result nameAlreadyInUse(),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return nameAlreadyInUse();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result unknownDomainLayerError(),
    Result serverError(),
    Result notFoundError(),
    Result cacheError(),
    Result geoLocationError(),
    Result usernameAlreadyInUse(),
    Result unAuthorizedError(),
    Result nameAlreadyInUse(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (nameAlreadyInUse != null) {
      return nameAlreadyInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result unknownDomainLayerError(UnknownDomainLayerError value),
    @required Result serverError(ServerError value),
    @required Result notFoundError(NotFoundError value),
    @required Result cacheError(CacheError value),
    @required Result geoLocationError(GeoLocationError value),
    @required Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    @required Result unAuthorizedError(UnAuthorizedError value),
    @required Result nameAlreadyInUse(NameAlreadyInUse value),
  }) {
    assert(unknownDomainLayerError != null);
    assert(serverError != null);
    assert(notFoundError != null);
    assert(cacheError != null);
    assert(geoLocationError != null);
    assert(usernameAlreadyInUse != null);
    assert(unAuthorizedError != null);
    assert(nameAlreadyInUse != null);
    return nameAlreadyInUse(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result unknownDomainLayerError(UnknownDomainLayerError value),
    Result serverError(ServerError value),
    Result notFoundError(NotFoundError value),
    Result cacheError(CacheError value),
    Result geoLocationError(GeoLocationError value),
    Result usernameAlreadyInUse(UsernameAlreadyInUse value),
    Result unAuthorizedError(UnAuthorizedError value),
    Result nameAlreadyInUse(NameAlreadyInUse value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (nameAlreadyInUse != null) {
      return nameAlreadyInUse(this);
    }
    return orElse();
  }
}

abstract class NameAlreadyInUse implements CoreFailure {
  const factory NameAlreadyInUse() = _$NameAlreadyInUse;
}
